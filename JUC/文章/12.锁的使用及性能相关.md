# 锁的使用及性能相关

## 概述

所有锁（包括内置锁和高级锁）都是有性能消耗的，也就是说在高并发的情况下，由于锁机制带来的上下文切换、资源同步等消耗是非常可观的。在某些极端情况下，线程在锁上的消耗可能比线程本身的消耗还要多。

所以如果可能的话，在任何情况下都尽量少用锁。

## 锁的一些概念

### 死锁

如果一个线程永远不释放另外一个线程需要的资源那么就会导致死锁。

这有两种情况：

	1. 线程A永远不释放锁，结果B一直拿不到锁，所以线程B就“死掉”了；
	
	2. 线程A拥有线程B需要的锁Y，同时线程B拥有线程A需要的锁X，那么这时候线程A/B互相依赖对方释放锁，于是二者都“死掉”了。
	
	3. 如果一个线程总是不能被调度，那么等待此线程结果的线程可能就死锁了。这种情况叫做线程饥饿死锁。

	饥饿死锁如：非公平锁中，如果某些线程非常活跃，在高并发情况下这类线程可能总是拿到锁，那些活跃度低的线程可能就一直拿不到锁，这样就发生了“饥饿死”。


避免死锁的解决方案是：

	1. 尽可能的按照锁的使用规范请求锁，另外锁的请求粒度要小（不要在不需要锁的地方占用锁，锁不用了尽快释放）；

	2. 在高级锁里面总是使用tryLock或者定时机制（就是指定获取锁超时的时间，如果时间到了还没有获取到锁那么就放弃）。

### 活锁

活锁描述的是线程总是尝试某项操作却总是失败的情况。

这种情况下尽管线程没有被阻塞，但是任务却总是不能被执行。

	1. 一个死循环里面总是尝试做某件事，结果却总是失败，现在线程将永远不能跳出这个循环。

	2.在一个队列中每次从队列头取出一个任务来执行，每次都失败，然后将任务放入队列头，接下来再一次从队列头取出任务执行，仍然失败。

	3.发生在“碰撞协让”情况下：两个人过独木桥，如果在半路相撞，双方礼貌退出去然后再试一次。如果总是失败，那么这两个任务将一直无法得到执行。

### 性能

由于锁总是带了性能影响，所以是否使用锁和使用锁的场合就变得尤为重要。

如果在一个高并发的Web请求中使用了强制的独占锁，那么就可以发现Web的吞吐量将急剧下降。

为了利用并发来提高性能，更有效的利用现有的资源，同时让程序尽可能的开拓更多可用的资源。

这意味着**机器尽可能的处于忙碌的状态，通常意义是说CPU忙于计算**，而不是等待。

### 线程阻塞

	锁机制的实现通常需要操作系统提供支持，显然这会增加开销。
	
	当锁竞争的时候，失败的线程必然会发生阻塞。
	
	JVM既能自旋等待（不断尝试，直到成功，很多CAS就是这样实现的），也能够在操作系统中挂起阻塞的线程，直到超时或者被唤醒。
	
	通常情况下这取决于上下文切换的开销以及与获取锁需要等待的时间二者之间的关系。

	自旋等待适合于比较短的等待，而挂起线程比较适合那些比较耗时的等待。
	
	挂起一个线程可能是因为无法获取到锁，或者需要某个特定的条件，或者耗时的I/O操作。
	
	挂起一个线程需要两次额外的上下文切换以及操作系统、缓存等多资源的配合，
	如果线程被提前换出，那么一旦拿到锁或者条件满足，那么又需要将线程换回执行队列，这对线程而言，两次上下文切换可能比较耗时。

### 锁竞争

影响锁竞争性的条件有两个：锁被请求的频率和每次持有锁的时间。显然当而这二者都很小的时候，锁竞争不会成为主要的瓶颈。但是如果锁使用不当，导致二者都比较大，那么很有可能CPU不能有效的处理任务，任务被大量堆积。

所以减少锁竞争的方式有下面三种：

1. 减少锁持有的时间
2. 减少锁请求的频率
3. 采用共享锁取代独占锁

## 总结

+ 锁肯定会带来性能的消耗，使用时需要慎重
+ 首先保证数据的安全，然后再优化锁的性能