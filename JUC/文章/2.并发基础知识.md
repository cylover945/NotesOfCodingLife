# 并发编程的前置知识
- - - 
## 并发和并行

+ **并发**
	
	当有多个线程在操作时,如果系统只有一个CPU,则它根本不可能真正同时进行一个以上的线程，它只能把CPU运行时间划分成若干个时间段,再将时间 段分配给各个线程执行，在一个时间段的线程代码运行时，其它线程处于挂起状。这种方式我们称之为并发(Concurrent)。
	
+	**并行**

	当系统有一个以上CPU时,则线程的操作有可能非并发。当一个CPU执行一个线程时，另一个CPU可以执行另一个线程，两个线程互不抢占CPU资源，可以同时进行，这种方式我们称之为并行(Parallel)。
+ **并发与并行的区别**

	通俗的说，并发是指一段时间内，多个线程使用同一CPU，并行是指多个线程在同一时刻使用多个CPU(一一对应)。
## 程序在计算机中的执行

+ 程序执行过程

	计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。

　　也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。

		比如下面的这段代码：
	
			i = i + 1;
			执行过程：
			1.从主存当中读取i的值，然后复制一份到高速缓存当中
			2.CPU执行指令对i进行加1操作，然后将数据写入高速缓存
			3.将高速缓存中i最新的值刷新到主存当中


　　这个代码在单线程中运行没问题，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。

　　比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。
	
		实际可能存在下面这种情况：

    		1.初始化，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中,两个缓存中i=0
			2.线程1进行加1操作，然后把i的最新值1写入到内存,内存中i=1
			3.此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存中
			4.最后结果，内存中i=1

　　最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种**被多个线程访问的变量为共享变量**。

　　也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。

　　为了解决缓存不一致性问题，通常来说有以下2种解决方法：

　　1）通过在总线加LOCK#锁的方式

　　2）通过缓存一致性协议

　　这2种方式都是硬件层面上提供的方式。

　　在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。

　　但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。

　　所以就出现了缓存一致性协议。最出名的就是Intel 的MESI协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的。它核心的思想是：**当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。**


##  并发编程的基本概念

+ **原子性**：即一个操作或者多个操作，要么全部执行成功，要么全部都不执行。

　　一例如银行账户转账问题：

　　比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。如果只执行成功了一半，A的钱少了，B的钱没有增加，肯定是不行的。

　　所以这2个操作必须要具备原子性才能保证不出现问题。

+ **可见性**：当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。


　　举个简单的例子，看下面这段代码：

		//线程1执行的代码
		int i = 0;
		i = 10;
		
		//线程2执行的代码
		j = i;
		线程1--->CPU1 将i值改成10，没有马上写入主存
		线程2--->CPU2 线程1还没有把10写入主存时，线程2执行，读取到的i还是0

　　这就是可见性问题，线程1对变量i修改了之后，线程2没有立即看到线程1修改的值。

+ **有序性**：即程序执行的顺序按照代码的先后顺序执行。

	有序性举个简单的例子，看下面这段代码：

		int i = 0;              
		boolean flag = false;
		i = 1;                //语句1  
		flag = true;          //语句2
	JVM在真正执行这段代码的时候不会保证语句1一定在语句2前面执行。因为这里可能会发生**指令重排序**（Instruction Reorder）。

　　**指令重排序**：一般来说，处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。

　　比如上面的代码中，语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而语句1后执行。

　　但是要注意，虽然处理器会对指令进行重排序，但是它会保证程序最终结果会和代码顺序执行结果相同，那么它靠什么保证的呢？再看下面一个例子：

		int a = 10;    //语句1
		int r = 2;    //语句2
		a = a + 3;    //语句3
		r = a*a;     //语句4
这段代码有4个语句，那么可能的一个执行顺序是：

　　那么可不可能是这个执行顺序呢： 语句2   语句1    语句4   语句3

　　不可能，因为处理器在进行重排序时是会考虑指令之间的数据依赖性，如果一个指令Instruction 2必须用到Instruction 1的结果，那么处理器会保证Instruction 1会在Instruction 2之前执行。

　　虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？下面看一个例子：

		//线程1:
		context = loadContext();   //语句1
		inited = true;   //语句2
		
		//线程2:
		while(!inited ){
		 sleep()
		}
		doSomethingwithconfig(context);
上面代码中，由于语句1和语句2没有数据依赖性，因此可能会被重排序。假如发生了重排序，在线程1执行过程中先执行语句2，而此是线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingwithconfig(context)方法，而此时context并没有被初始化，就会导致程序出错。

 　　从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。

　　也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。

## 程序在Java虚拟机中的执行


　　Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。

	　　例如：
		i  = 10;
		执行线程必须先在自己的工作线程中对变量i所在的缓存行进行赋值操作，然后再写入主存当中。而不是直接将数值10写入主存当中。

+ Java中的原子性

　　在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。

　　Java内存模型只保证了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过**synchronized**和**Lock**来实现。由于synchronized和Lock能够保证任一时刻只有一个线程执行该代码块，从而保证了原子性。

+ Java中的可见性

　　对于可见性，Java提供了volatile关键字来保证可见性。

　　当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。

　　而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。

　　通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。

+ Java中的有序性

　　在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。

　　在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。

　　另外，Java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为 happens-before 原则。如果两个操作的执行次序无法从happens-before原则推导出来，那么它们就不能保证它们的有序性，虚拟机可以随意地对它们进行重排序。

　　下面就来具体介绍下happens-before原则（先行发生原则）：

	程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作

	锁定规则：一个unLock操作先行发生于后面对同一个锁额lock操作

	volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作

	传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C

	线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作

	线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生

	线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行

	对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始

									----------摘自《深入理解Java虚拟机》。
